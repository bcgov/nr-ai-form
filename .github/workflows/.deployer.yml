name: .Terraform Deployer

on:
  workflow_call:
    inputs:
      ### Required
      environment_name:
        description: 'The name of the environment to deploy to'
        required: true
        default: 'dev'
        type: string
      command:
        description: 'The terragrunt command to run'
        required: true
        default: 'apply'
        type: string
      tag:
        description: 'The tag of the containers to deploy'
        default: 'latest'
        type: string
        required: false
      app_env:
        required: false
        type: string
        description: 'The APP env separates between Azure ENV and Actual APP, since Azure dev is where PR, and TEST is deployed'
      stack_prefix:
        required: true
        type: string
        description: 'The stack prefix to use for the resources'
      deployment_type:
        required: false
        type: string
        default: 'app_service'
        description: 'The deployment type: app_service or container_apps'
      
env:
    TG_VERSION: 0.63.6
    TF_VERSION: 1.12.2
    TF_LOG: ERROR
    AZURE_REGION: Canada Central
permissions:
  id-token: write # This is required for requesting the JWT
  contents: write # This is required for actions/checkout
jobs:
 infra:
  environment: ${{ inputs.environment_name }}
  name: Terragrunt ${{inputs.command}}  ${{ inputs.environment_name }}
  runs-on: ubuntu-24.04
  steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Azure CLI Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
    
    - name: Setup Terragrunt
      uses: autero1/action-terragrunt@aefb0a43c4f5503a91fefb307745c4d51c26ed0e # v3
      with:
        terragrunt-version: ${{ env.TG_VERSION }}
    
    - name: Pre-Migration State Cleanup
      if: inputs.command == 'apply'
      working-directory: terragrunt/${{ inputs.environment_name }}
      env:
          target_env: ${{ inputs.environment_name }}
          azure_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          vnet_resource_group_name: ${{ vars.RESOURCE_GROUP_NAME }} 
          vnet_name: ${{ vars.VNET_NAME }}
          conversation_agent_image: "${{ github.repository }}/conversation_agent:${{ inputs.tag }}"
          formsupport_agent_image: "${{ github.repository }}/formsupport_agent:${{ inputs.tag }}"
          orchestrator_agent_image: "${{ github.repository }}/orchestrator_agent:${{ inputs.tag }}"
          stack_prefix: ${{ inputs.stack_prefix }}
          azure_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          repo_name: ${{ github.event.repository.name }}
          app_env: ${{ inputs.app_env }}
          storage_account_name: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
          vnet_address_space: ${{ vars.VNET_ADDRESS_SPACE }}
          deployment_type: ${{ inputs.deployment_type }}
          # Azure OpenAI Configuration
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_API_VERSION: ${{ vars.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT_NAME: ${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}
          # Azure Search Configuration
          AZURE_SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}
          AZURE_SEARCH_KEY: ${{ secrets.AZURE_SEARCH_KEY }}
          AZURE_SEARCH_INDEX_NAME: ${{ secrets.AZURE_SEARCH_INDEX_NAME }}
          # Azure Document Intelligence Configuration
          AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT: ${{ secrets.AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT }}
          AZURE_DOCUMENT_INTELLIGENCE_KEY: ${{ secrets.AZURE_DOCUMENT_INTELLIGENCE_KEY }}
          # Azure Storage Configuration
          AZURE_STORAGE_ACCOUNT_NAME: ${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}
          AZURE_STORAGE_ACCOUNT_KEY: ${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}
          AZURE_STORAGE_CONTAINER_NAME: ${{ secrets.AZURE_STORAGE_CONTAINER_NAME }}
      run: |
        # Initialize Terragrunt to access state
        echo "Initializing Terragrunt..."
        terragrunt init -upgrade
        
        # Remove problematic resource directly from remote state using Terraform
        echo "Checking remote state for problematic resource..."
        if terragrunt state list 2>/dev/null | grep -q 'module.network.azapi_resource.container_apps_subnet'; then
          echo "Found azapi_resource.container_apps_subnet - removing from remote state..."
          # Use -lock=false to avoid lock conflicts
          terragrunt state rm -lock=false 'module.network.azapi_resource.container_apps_subnet[0]' || true
          echo "Removed from state"
        else
          echo "Resource not found in state (may already be migrated)"
        fi
    
    - name: Image Tags
      id: image-tags
      shell: bash
      run: |
        # Full registry URLs for Azure CLI sidecar deployment
        CONVERSATION_AGENT_FULL="ghcr.io/${{ github.repository }}/conversation_agent:${{ inputs.tag }}"
        FORMSUPPORT_AGENT_FULL="ghcr.io/${{ github.repository }}/formsupport_agent:${{ inputs.tag }}"
        ORCHESTRATOR_AGENT_FULL="ghcr.io/${{ github.repository }}/orchestrator_agent:${{ inputs.tag }}"
        
        # Strip registry prefix for Terraform (registry added via docker_registry_url)
        ORCHESTRATOR_AGENT_TF="${{ github.repository }}/orchestrator_agent:${{ inputs.tag }}"
        
        echo "conversation-agent-image=$CONVERSATION_AGENT_FULL" >> $GITHUB_OUTPUT
        echo "formsupport-agent-image=$FORMSUPPORT_AGENT_FULL" >> $GITHUB_OUTPUT
        echo "orchestrator-agent-image-full=$ORCHESTRATOR_AGENT_FULL" >> $GITHUB_OUTPUT
        echo "orchestrator-agent-image=$ORCHESTRATOR_AGENT_TF" >> $GITHUB_OUTPUT
    
    - name: Terragrunt ${{inputs.command}}
      working-directory: terragrunt/${{ inputs.environment_name }}
      env:
          target_env: ${{ inputs.environment_name }}
          azure_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
          vnet_resource_group_name: ${{ vars.RESOURCE_GROUP_NAME }} 
          vnet_name: ${{ vars.VNET_NAME }}
          api_image: ${{ steps.image-tags.outputs.conversation-agent-image }}
          conversation_agent_image: ${{ steps.image-tags.outputs.conversation-agent-image }}
          formsupport_agent_image: ${{ steps.image-tags.outputs.formsupport-agent-image }}
          orchestrator_agent_image: ${{ steps.image-tags.outputs.orchestrator-agent-image }}
          stack_prefix: ${{ inputs.stack_prefix }}
          azure_client_id: ${{ secrets.AZURE_CLIENT_ID }}
          repo_name: ${{ github.event.repository.name }}
          app_env: ${{ inputs.app_env }}
          storage_account_name: ${{ vars.TFSTATE_STORAGE_ACCOUNT }}
          vnet_address_space: ${{ vars.VNET_ADDRESS_SPACE }}
          # Azure OpenAI Configuration
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_API_VERSION: ${{ vars.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT_NAME: ${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}
          # Azure Search Configuration
          AZURE_SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}
          AZURE_SEARCH_KEY: ${{ secrets.AZURE_SEARCH_KEY }}
          AZURE_SEARCH_INDEX_NAME: ${{ secrets.AZURE_SEARCH_INDEX_NAME }}
          # Azure Document Intelligence Configuration
          AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT: ${{ secrets.AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT }}
          AZURE_DOCUMENT_INTELLIGENCE_KEY: ${{ secrets.AZURE_DOCUMENT_INTELLIGENCE_KEY }}
          # Azure Storage Configuration
          AZURE_STORAGE_ACCOUNT_NAME: ${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}
          AZURE_STORAGE_ACCOUNT_KEY: ${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}
          AZURE_STORAGE_CONTAINER_NAME: ${{ secrets.AZURE_STORAGE_CONTAINER_NAME }}
      run: |
          # Run terraform with lock=false to avoid state lock issues
          terragrunt run-all ${{inputs.command}} --terragrunt-non-interactive -lock=false
    
    - name: Deploy Sidecars (Conversation & Form Support Agents)
      if: inputs.command == 'apply' && success()
      shell: bash
      env:
          CONVERSATION_AGENT_IMAGE: ${{ steps.image-tags.outputs.conversation-agent-image }}
          FORMSUPPORT_AGENT_IMAGE: ${{ steps.image-tags.outputs.formsupport-agent-image }}
      run: |
          echo "Deploying sidecars (Conversation & Form Support Agents)..."
          
          # Construct app name from stack prefix and environment
          APP_NAME="${{ inputs.stack_prefix }}-api-${{ inputs.app_env }}"
          RESOURCE_GROUP="${{ vars.RESOURCE_GROUP_NAME }}"
          
          echo "Deploying to App Service: $APP_NAME in $RESOURCE_GROUP"
          
          # Deploy Conversation Agent Sidecar (port 8000)
          echo "Deploying Conversation Agent..."
          az webapp sitecontainers create \
            --resource-group "$RESOURCE_GROUP" \
            --name "$APP_NAME" \
            --container-name "conversation_agent" \
            --image "$CONVERSATION_AGENT_IMAGE" \
            --target-port 8000 \
            --is-main false \
            --system-assigned-identity true \
            || echo "Conversation Agent deploy completed (may already exist)"
          
          # Deploy Form Support Agent Sidecar (port 8001)
          echo "Deploying Form Support Agent..."
          az webapp sitecontainers create \
            --resource-group "$RESOURCE_GROUP" \
            --name "$APP_NAME" \
            --container-name "formsupport_agent" \
            --image "$FORMSUPPORT_AGENT_IMAGE" \
            --target-port 8001 \
            --is-main false \
            --system-assigned-identity true \
            || echo "Form Support Agent deploy completed (may already exist)"
          
          # List deployed sidecars to confirm
          echo ""
          echo "Deployed sidecars:"
          az webapp sitecontainers list \
            --resource-group "$RESOURCE_GROUP" \
            --name "$APP_NAME" \
            --query "[].{Name:name, Image:image, Port:targetPort, Auth:authType}" \
            --output table